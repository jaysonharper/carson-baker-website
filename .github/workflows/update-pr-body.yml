name: Update PR Description

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  update-pr-body:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build PR body (Conventional Commits aware)
        id: build
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          HEAD_REF: ${{ github.event.pull_request.head.ref }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Fetch full refs to ensure logs available
          git fetch origin "$BASE_REF" "$HEAD_REF" --depth=200 || true

          # Retrieve existing body
          existing_body=$(gh pr view "$PR_NUMBER" --json body --jq '.body' || echo "")

          marker='<!-- AUTO-GENERATED:PR-DESCRIPTION -->'
          manual_marker='<!-- MANUAL-EDIT -->'

          if echo "$existing_body" | grep -q "$manual_marker"; then
            echo "Manual edit marker found; skipping auto-update." > summary.txt
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Collect commit subjects between base and head (exclude merge commits from GitHub UI)
          commit_range="origin/${BASE_REF}..${HEAD_SHA}"
          mapfile -t commits < <(git log --pretty=format:'%s' $commit_range | grep -v '^Merge pull request' || true)

          if [ ${#commits[@]} -eq 0 ]; then
            commits=("Update")
          fi

          # Categorize commits according to Conventional Commits
          feats=()
          fixes=()
          docs=()
          refactors=()
          perf=()
          tests=()
          chores=()
          build=()
          ci=()
          others=()
          breaking=()

          regex='^([a-zA-Z]+)(\([^)]+\))?(!)?:[ ]+(.*)'
          for c in "${commits[@]}"; do
            type=""; scope=""; bang=""; desc="";
            if [[ $c =~ $regex ]]; then
              type=$(echo "${BASH_REMATCH[1]}" | tr '[:upper:]' '[:lower:]')
              scope=${BASH_REMATCH[2]}
              bang=${BASH_REMATCH[3]:-}
              desc=${BASH_REMATCH[4]}
              pretty="${desc}"
              # Append scope in parentheses for clarity (without surrounding parentheses duplication)
              if [ -n "$scope" ]; then
                scope_clean=${scope#(}; scope_clean=${scope_clean%)}
                pretty="$scope_clean: $desc"
              fi
              case "$type" in
                feat) feats+=("$pretty") ;;
                fix) fixes+=("$pretty") ;;
                docs) docs+=("$pretty") ;;
                refactor) refactors+=("$pretty") ;;
                perf) perf+=("$pretty") ;;
                test) tests+=("$pretty") ;;
                chore) chores+=("$pretty") ;;
                build) build+=("$pretty") ;;
                ci) ci+=("$pretty") ;;
                revert) fixes+=("revert: $pretty") ;;
                *) others+=("$c") ;;
              esac
              if [ -n "$bang" ]; then
                breaking+=("$type$scope: $desc")
              fi
            else
              # Fallback: not matching conventional format
              others+=("$c")
            fi
          done

          # Deduplicate function
          dedupe() { awk '!seen[$0]++'; }

          section() {
            local title="$1"; shift
            local arr=("$@")
            if [ ${#arr[@]} -gt 0 ]; then
              printf '### %s\n' "$title"
              printf '%s\n' "${arr[@]}" | dedupe | sed 's/^/- /'
              printf '\n'
            fi
          }

          # Determine summary: first feature, else first fix, else first commit
          if [ ${#feats[@]} -gt 0 ]; then
            first_commit="feat: ${feats[0]}"
          elif [ ${#fixes[@]} -gt 0 ]; then
            first_commit="fix: ${fixes[0]}"
          else
            first_commit="${commits[0]}"
          fi

          changes_sections=""
          changes_sections+=$(section "Features" "${feats[@]}" || true)
          changes_sections+=$(section "Fixes" "${fixes[@]}" || true)
          changes_sections+=$(section "Documentation" "${docs[@]}" || true)
          changes_sections+=$(section "Refactors" "${refactors[@]}" || true)
          changes_sections+=$(section "Performance" "${perf[@]}" || true)
          changes_sections+=$(section "Tests" "${tests[@]}" || true)
          changes_sections+=$(section "Chores" "${chores[@]}" || true)
          changes_sections+=$(section "Build" "${build[@]}" || true)
          changes_sections+=$(section "CI" "${ci[@]}" || true)
          changes_sections+=$(section "Other" "${others[@]}" || true)
          if [ ${#breaking[@]} -gt 0 ]; then
            changes_sections+=$(section "Breaking Changes" "${breaking[@]}" || true)
          fi

          new_body="${marker}\n## Summary\n${first_commit}\n\n## Changes\n${changes_sections}\n## Motivation / Context\n<!-- Add context or link issues. Remove this line if not needed. -->\n\n## Screenshots / Demos (if UI)\n<!-- Attach before/after images or GIFs. -->\n\n## Testing\nSteps to verify:\n1. \n2. \n3. \n\n## Checklist\n- [ ] Build passes (npm run build)\n- [ ] Tests pass (npm test)\n- [ ] Storybook updated (if components changed)\n- [ ] Docs updated (README / docs/*)\n- [ ] No sensitive info committed\n\n## Additional Notes\n<!-- Optional extra information. -->\n"

          # If existing body had the marker, replace from marker downward; else replace entirely
          if echo "$existing_body" | grep -q "$marker"; then
            # Preserve anything above marker
            preserved=$(echo "$existing_body" | awk -v m="$marker" 'BEGIN{found=0} {if($0==m){found=1} if(!found) print $0}')
            if [ -n "$preserved" ]; then
              final_body="$preserved\n$new_body"
            else
              final_body="$new_body"
            fi
          else
            final_body="$new_body"
          fi

          printf '%s' "$final_body" > pr_body.txt
          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Update PR
        if: steps.build.outputs.skip == 'false'
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr edit "$PR_NUMBER" --body-file pr_body.txt

      - name: Log result
        run: |
          if [ '${{ steps.build.outputs.skip }}' = 'true' ]; then
            echo 'Skipped updating PR body (manual edit marker present).'
          else
            echo 'PR body updated.'
          fi
